# Network analysis with `R`

```{r, message=FALSE, warning=FALSE}
library("igraph")
library("igraphdata")
```

## Introduction

Work in progress[^tutorial]

[^tutorial]: Obviously I want to provide a self-contained manual, however, there are as well some pretty good and more extensive tutorials on internet: e.g., the one over [here](http://kateto.net/networks-r-igraph/).

## Creating networks

There are various ways to create a network: one can it oneself, one can create a structured network, and one can read a network from file or the internet. (The latter is typically done with very large and dynamics network data.)

### Creating network yourself

First of all, I will show how to create a network "by hand". We first start with an undirected network. Suppose we have a network with four nodes (named 1,2, 3 and, you guessed it, 4). Then we can create a graph called `g_4` by: 

```{r, message=FALSE}
g_4 <- graph (edges = c(1,2,2,3,3,4, 4,1), n = 4, directed = FALSE)
```

Let us have a look at `g_4`

```{r}
g_4
```

So, `g_4` is an igraph sort of object which has four edges `1--2 2--3 3--4 1--4`. Note that these coincide with `c(1,2,2,3,3,4, 4,1)`, so an edge is always formed by two components (they do not have to be numbers). Now plotting `g_4` leads to:

```{r, message = FALSE}
plot(g_4)
```

The connectivity matrix of the network can be directly given by:

```{r}
g_4[]
```

Now, for more directed graphs we need to set `directed = TRUE`.  

```{r, message=FALSE}
g_4 <- graph (edges = c(1,2,2,3,3,4, 4,1), n = 4, directed = TRUE)
```

with as plot

```{r, message = FALSE}
plot(g_4)
```

Graphs may also be generated by using `-`, `-+` and `+-+`, in combination with the command `graph_from_literal`. For example:

```{r, message = FALSE}
g_directed <- graph_from_literal(A-+B, B +-+ C, C+-A)
plot(g_directed)
```

Finally, we can influence the color and sizes (amongst others) of all the elements of the network, so:

```{r}
plot(g_directed, edge.arrow.size=2,vertex.size = 50, vertex.color = "blue" )
```

However, this way of creating of networks is not very efficient. We therefore offer some other ways as well, starting with created directly (well-structured networks).  

### Structured networks

With the package `igraph` it is rather straighforward to create structured networks. Let's start with an empty network. We therefore use the command `make_empty_graph(500` in order to create 500 nodes and no links.  

```{r, message=FALSE}
g_empty <- make_empty_graph(500)
plot(g_empty, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

The other extreme is obviously the fully connected network. With the command `make_full_graph(40)` we can create a fully connected network between 40 nodes. (Please do not do 500 nodes; it takes a long time to create that network (with $500 \times 500 - 500$ links)). 

```{r, message = FALSE}
g_full <- make_full_graph(40)
plot(g_full, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

The `make_star(500)` command create a star network (or a hub-and-spoke network) with 500 nodes.
```{r, message = FALSE}
g_star <- make_star(500)
plot(g_star, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

With the `make_tree(500, children = 3, mode="undirected` command, we create an undirected hierarchical tree with each time tree children 

```{r, message = FALSE}
g_tree <- make_tree(500, children = 3, mode = "undirected")
plot(g_tree, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

And the `graph.ring(500)` creates a ring (or line) structure where each node is connected to two other nodes in a sequential way

```{r, message = FALSE}
g_ring <- graph.ring(500)
plot(g_ring, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

For the real-world network we can use the following commands. First, the command `erdos.renyi.game(500, 0.005)` creates a random network, where each node has a probability of 0.005 to be connected to each other node.  

```{r}
plot(erdos.renyi.game(500, 0.005), vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

For the small-world network, we need to rewire the ring network. We can do by the command `rewire` as follows:
```{r}
plot(rewire(g_ring,each_edge(prob = 0.5)), vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

Note that the probability of rewiring is now 0.5.

Finally, for a power-law we need to invoke an algorithm. In this case the `barabasi.game`, where we now create a power-law type of network with the following underlying formula $P(k) = k^{-0.5}$.

```{r, message = FALSE}
g_power_law <- barabasi.game(500, 0.5)
plot(g_power_law, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)
```

Note the tree-like structure.

### Reading in networks

There are various sources for networks on the internet. One of them is [nexus](http://nexus.igraph.org/). With the following command I import a network from this website:

```{r, message = FALSE}
g_florence <- nexus_get("padgett")
```

which contains business and marriage ties (PADGB)in 14th century Florence and looks like this

```{r, message = FALSE}
plot(g_florence$PADGB)
```

Another good but smaller source is the `igraphdata` package which actually contains a network of american domestic flights. 

Another possibility is to read in the data from a `.csv` file. Something like (I took and modified the example from [http://stackoverflow.com/questions/23687806/creating-a-network-graph-using-igraph-in-r](http://stackoverflow.com/questions/23687806/creating-a-network-graph-using-igraph-in-r)):

```{r, message = FALSE}
# Make up data
relations <- data.frame(from=c("Bob", "Cecil", "Cecil", "David", "David", "Esmeralda"),
                        to=c("Alice", "Bob", "Alice", "Alice", "Bob", "Alice"))
# Alternatively, you could read in the data from a similar CSV file as follows:
# relations <- read.csv("relations.csv")

# Load (DIRECTED) graph from data frame 
g_relations <- graph.data.frame(relations, directed=TRUE)
plot(g_relations)
```

Note that this only requires a from and to columns in a `.csv` file, which resembles trade, commuting, migration and transport networks (in a gravity-model type of way). The only thing is that we need to convert this data in a igraph structure with `graph.data.frame`. 

## Network characteristics

So, it is fine that you have a network, but what about the network characteristics. Well these are easily given once you have a network. 

For density, or the completeness of the network,  one can look at 

```{r}
edge_density(g_florence$PADGB)
```

Which give the proportion of the present edges from all possible edges in the network. 

The diameter of a network can be retrieved as:

```{r}
diameter(g_florence$PADGB)
```

somewhat more interesting is given by the degree function which gives the number of connections. For our power-law network this amounts to

```{r}
deg <- degree(g_power_law)
deg
```

which is not that insightful, but a histogram is:

```{r, message=FALSE}
hist(deg)
```

Which is typical for a power-law.

The `degree_distribution` is insightful here as well

```{r, message = FALSE}
plot(degree_distribution(g_power_law, cumulative = TRUE))
```

Finally, we may be interested in the shortest path. This can easily be retrieved using distances (with underlying Dijkstra's algorithm) as follows for the Florence network:

```{r}
distances(g_florence$PADGB)
```

Note that the Pucci family is not in the network and therefore the distances are set to infinity. 